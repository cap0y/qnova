 지능형 교육 콘텐츠 생성 플랫폼 (SaaS) 구축 로드맵
1. 시스템 아키텍처 및 서비스 구조 (Architecture & Structure)
기존 LMS DB 스키마(사용자, 결제 등)를 재사용하되, AI 처리 파이프라인(AI Processing Pipeline)을 별도 모듈로 설계하여 시스템 부하를 분산하고 확장성을 확보합니다.
🛠 전체 서비스 흐름도
Data Ingestion (입력 계층): 사용자가 HWP, PDF 파일을 업로드 (Drag & Drop UI 적용).
Preprocessing (전처리 계층):
서버에서 파일 포맷 식별 및 텍스트/이미지 추출.
HWP/PDF 파싱을 위한 전용 파서(Parser) 모듈 가동.
Intelligence Engine (생성 계층):
추출된 텍스트를 LLM(Gemini)에 전송.
프롬프트 엔지니어링 모듈: 사용자가 선택한 출제 유형(객관식, 주관식, 빈칸 추론 등)에 맞춰 최적화된 프롬프트 주입.
Rendering Engine (출력 계층):
생성된 문제와 해설을 구조화된 데이터(JSON)로 변환.
미리 정의된 템플릿(Pretendard 폰트 적용)에 매핑하여 PDF/HWP 포맷으로 렌더링.
2. 프로세스별 상세 개발 전략 (Development Strategy)
Phase 1. 입력 및 전처리 기술 (Input Processing)
목표: 저작권 보호를 위한 비식별화 처리 및 고정밀 텍스트 추출
UI/UX:
기존 client 폴더 내에 ProblemMaker 페이지 신설.
파일 업로드 시 즉시 페이지 수, 텍스트 분량을 분석하여 사용자에게 예상 소요 시간(Credit) 제시.
백엔드 로직 (Node.js):
PDF: pdf-parse 라이브러리를 사용하여 텍스트 레이어 추출.
HWP: HWP는 바이너리 구조가 복잡하므로, Node.js에서 Python 스크립트(pyhwp 또는 olefile)를 Child Process로 호출하거나, 클라우드 변환 API를 경유하여 텍스트를 추출하는 하이브리드 파싱 전략 사용.
Phase 2. 생성 알고리즘 및 AI 모델링 (Gemini Integration)
목표: 타사 대비 경쟁력 확보를 위한 고도화된 프롬프트 체이닝(Prompt Chaining)
LLM 연동: Google Gemini API (@google/generative-ai) 도입.
Context Window 최적화: 긴 문서(교과서 전체 단원 등) 처리를 위해 문서를 의미 단위(Chunk)로 쪼개어 처리하는 RAG(Retrieval-Augmented Generation) 기법 일부 도입.
문제 유형별 프롬프트 세트 구축:
변형 문제: "다음 지문을 바탕으로 수능형 3점 문항을 생성하고, 매력적인 오답(Distractor)을 4개 포함하시오."
빈칸 추론: "핵심 키워드를 분석하여, 문맥상 중요한 단어를 빈칸으로 처리하시오."
Phase 3. 출력 및 결과물 렌더링 (Output Formatting)
목표: '쏠북 엑스퍼트' 수준의 디자인 퀄리티 및 Pretendard 폰트 적용
PDF 생성:
React 컴포넌트(@react-pdf/renderer)를 사용하여 화면에 보이는 그대로 고해상도 PDF 렌더링.
서버 사이드 렌더링(SSR)을 통해 대용량 파일도 안정적으로 변환.
HWP 생성:
직접적인 HWP 바이너리 생성은 기술적 난이도가 매우 높음.
전략: HTML 구조로 변환 후, 이를 한글(Hwp) 호환 포맷(HWPXML)으로 변환하거나, 1차적으로 PDF로 제공하고 편집 가능한 포맷은 Word(DOCX)로 우회 제공 후 변환 가이드 제공 (초기 MVP 단계).
Phase 4. [R&D 과제] 이미지 인식 및 마킹 분석 (Advanced Feature)
목표: 손글씨/형광펜 인식을 통한 초개인화 문제 생성
Computer Vision 도입: OpenCV 또는 Google Cloud Vision API를 활용하여 이미지 내의 색상 영역(형광펜) 좌표 추출.
좌표 매핑 기술: 추출된 좌표의 텍스트를 OCR로 인식하여 "이 부분이 강조되었으니, 이 내용을 중심으로 문제를 출제하라"는 지시를 LLM에 전달하는 알고리즘 개발.
3. 데이터베이스 설계 변경안 (Database Schema)
기존 neondb 구조에 다음 테이블들을 추가하여 연동합니다.
-- 1. 업로드된 원본 자료 (저작권 관리 및 이력)
CREATE TABLE "source_materials" (
  "id" SERIAL PRIMARY KEY,
  "user_id" INTEGER NOT NULL REFERENCES "users"("id"),
  "file_name" TEXT NOT NULL,
  "file_type" TEXT NOT NULL, -- 'pdf', 'hwp', 'image'
  "file_url" TEXT NOT NULL,  -- S3 또는 로컬 저장 경로
  "parsed_text" TEXT,        -- 추출된 텍스트 캐싱
  "upload_date" TIMESTAMP DEFAULT NOW()
);

-- 2. 생성된 문제 세트 (Output)
CREATE TABLE "exam_generations" (
  "id" SERIAL PRIMARY KEY,
  "source_id" INTEGER NOT NULL REFERENCES "source_materials"("id"),
  "prompt_type" TEXT NOT NULL, -- 'summary', 'multiple_choice', 'blank'
  "options" JSONB,             -- 난이도, 문항 수 등 설정값
  "result_content" JSONB,      -- 생성된 문제 및 정답 데이터 (JSON 구조)
  "created_at" TIMESTAMP DEFAULT NOW()
);

-- 3. 구독 및 크레딧 (SaaS 수익 모델)
CREATE TABLE "user_credits" (
  "id" SERIAL PRIMARY KEY,
  "user_id" INTEGER NOT NULL REFERENCES "users"("id"),
  "remaining_credits" INTEGER DEFAULT 0, -- 문제 생성 가능 횟수
  "last_charged" TIMESTAMP
);
-- 1. 업로드된 원본 자료 (저작권 관리 및 이력)CREATE TABLE "source_materials" (  "id" SERIAL PRIMARY KEY,  "user_id" INTEGER NOT NULL REFERENCES "users"("id"),  "file_name" TEXT NOT NULL,  "file_type" TEXT NOT NULL, -- 'pdf', 'hwp', 'image'  "file_url" TEXT NOT NULL,  -- S3 또는 로컬 저장 경로  "parsed_text" TEXT,        -- 추출된 텍스트 캐싱  "upload_date" TIMESTAMP DEFAULT NOW());-- 2. 생성된 문제 세트 (Output)CREATE TABLE "exam_generations" (  "id" SERIAL PRIMARY KEY,  "source_id" INTEGER NOT NULL REFERENCES "source_materials"("id"),  "prompt_type" TEXT NOT NULL, -- 'summary', 'multiple_choice', 'blank'  "options" JSONB,             -- 난이도, 문항 수 등 설정값  "result_content" JSONB,      -- 생성된 문제 및 정답 데이터 (JSON 구조)  "created_at" TIMESTAMP DEFAULT NOW());-- 3. 구독 및 크레딧 (SaaS 수익 모델)CREATE TABLE "user_credits" (  "id" SERIAL PRIMARY KEY,  "user_id" INTEGER NOT NULL REFERENCES "users"("id"),  "remaining_credits" INTEGER DEFAULT 0, -- 문제 생성 가능 횟수  "last_charged" TIMESTAMP);
4. 제안된 개발 착수 계획 (Next Steps)
정부 과제 및 실제 서비스 런칭을 위해 지금 바로 수행해야 할 작업 순서입니다.
DB 마이그레이션: 위에서 정의한 테이블을 shared/schema.ts에 추가하고 DB에 반영합니다.
API 키 발급: Google Gemini API Key를 발급받아 환경 변수(.env)에 설정합니다.
파일 처리 서버 구축: Node.js 기반의 파일 업로드(multer) 및 텍스트 추출 라우터를 개발합니다.
이 방향으로 진행하시겠습니까? "승인"해 주시면 바로 Step 1. DB 스키마 설계 및 적용부터 코딩을 시작하겠습니다.